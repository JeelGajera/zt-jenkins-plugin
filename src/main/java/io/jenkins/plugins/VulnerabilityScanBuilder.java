package io.jenkins.plugins;

import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.*;
import hudson.model.AbstractProject;
import hudson.model.Result;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.BuildStepMonitor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import io.jenkins.plugins.models.ScanResponse;
import io.jenkins.plugins.services.ScanService;
import jenkins.tasks.SimpleBuildStep;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;

import java.io.IOException;
import java.io.PrintStream;

public class VulnerabilityScanBuilder extends Builder implements SimpleBuildStep {
    private String token;
    private boolean waitForAnalysis;

    /**
     * Only required parameter in the constructor;
     * waitForAnalysis stays false unless explicitly checked.
     */
    @DataBoundConstructor
    public VulnerabilityScanBuilder(String token) {
        this.token = token;
        this.waitForAnalysis = false;
    }

    public String getToken() {
        return this.token;
    }

    @DataBoundSetter
    public void setToken(String ZT_TOKEN) {
        this.token = ZT_TOKEN;
    }

    public boolean getWaitForAnalysis() {
        return this.waitForAnalysis;
    }

    @DataBoundSetter
    public void setWaitForAnalysis(boolean waitForAnalysis) {
        this.waitForAnalysis = waitForAnalysis;
    }

    @Override
    public void perform(@NonNull Run<?, ?> run, @NonNull FilePath workspace, @NonNull EnvVars env, @NonNull Launcher launcher, @NonNull TaskListener listener) throws InterruptedException, IOException {
        PrintStream logger = listener.getLogger();
        if (this.token == null || this.token.trim().isEmpty()) {
            run.setResult(Result.FAILURE);
            throw new AbortException("Please configure a valid ZT_TOKEN.");
        }

        try {
            // Initiate web scan
            logger.println("Initiating security scan request.");
            ScanResponse scanResponse = ScanService.initiateScan(this.token, logger);
            if (scanResponse.Status != 200) {
                run.setResult(Result.FAILURE);
                throw new AbortException("Failed to initiate scan. \nReason: " + scanResponse.Message);
            }

            logger.println("Scan started successfully.\nScan Report Url:" + scanResponse.Url);

            // Poll for scan completion
            if (this.waitForAnalysis) {
                boolean scanCompleted = ScanService.pollScanStatus(scanResponse.Code, logger);
                if (!scanCompleted) {
                    run.setResult(Result.FAILURE);
                    throw new AbortException("Scan did not complete successfully.");
                } else {
                    logger.println("Scan completed successfully.");
                }
            }
        } catch (Exception e) {
            run.setResult(Result.FAILURE);
            throw new AbortException("Status polling failed: " + e.getMessage());
        }
    }

    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {
        @Override
        public boolean isApplicable(Class<? extends AbstractProject> jobType) {
            return true;
        }

        @NonNull
        @Override
        public String getDisplayName() {
            return "ZeroThreat AI Security Scan";
        }

        public FormValidation doCheckToken(@QueryParameter String token) {
            if (token.isBlank()) {
                return FormValidation.error("ZT_TOKEN is require for initiating scan.");
            }
            return FormValidation.ok();
        }
    }

    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }
}
